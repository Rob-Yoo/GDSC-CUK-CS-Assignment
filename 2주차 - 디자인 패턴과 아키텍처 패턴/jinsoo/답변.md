## 디자인 패턴 면접 질문

### 1. 의존성 주입에 대해 설명해보고 의존성 주입을 하는 이유에 대해 설명해보세요.
의존성 주입(Dependency Injection, DI)란 외부에서 두 객체 간의 관계를 결정해주는 디자인 패턴으로, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존 관계가 고정되지 않도록 하고 런타임 시에 관계를 동적으로 주입해 주는 것을 말한다. 강하게 결합된 클래스들을 분리하고, 애플리케이션 실행 시점에 객체 간의 관계를 결정해 줌으로써 결합도를 낮추고 유연성을 확보해준다.
DI가 필요한 이유는 클래스의 책임을 최소화하여 리팩토링을 쉽게 할 수 있고, 코드를 재사용과 테스트를 용이하게 해준다.


<br/>
<br/>


### 2. 팩토리 메서드 패턴과 추상 팩토리 메서드 패턴에 대해 둘의 차이점을 중점으로 설명해보세요.
팩토리 메서드 패턴은 상위 클래스에서는 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에게 객체의 생성을 위임하는 패턴이다. 하위 클래스에서 팩토리 메서드를 오버라이딩하여 객체를 생성한다.
추상 팩토리 패턴은 연관된 하위 클래스를 특정 그룹으로 묶어서 한번에 교체할 수 있도록 하는 패턴이다. 팩토리 메서드 패턴과 유사한데 팩토리 메서드 패턴에서는 팩토리에서 구체적인 클래스를 지정하여 인스턴스를 생성하는 반면 추상 팩토리 메서드 패턴은 상위 팩토리 클래스가 따로 존재하여 하위 팩토리 클래스에 대한 인터페이스를 제공하고 인스턴스의 생성은 하위 팩토리 클래스에서 발생한다는 차이가 있다.

<br/>
<br/>

### 3. 프록시 패턴에 대해 설명해보고 언제 사용하는 것이 좋은지 설명해보세요.
- 프록시 패턴의 장점과 단점에 대해 설명해보세요.
- 데코레이터 패턴과의 차이점에 대해 설명해보세요.
<br/>
프록시 패턴은 객체 간의 간접적인 접근을 가능하게 하는 구조를 제공하는 패턴이다. 여기서 프록시란 대리자의 의미를 가지고 있다. 말 그대로 원본 객체를 바로 호출하는 것이 아니라, 원본 객체에 접근할 수 있는 대리자를 호출하는 패턴이다. 어떤 객체를 호출할 때 객체를 직접 호출하는 것이 아니라 대리자 객체를 호출하는 방식을 사용하면 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있다. 또한 실제 객체의 필요 시점까지 객체 생성을 미루는 지연 초기화가 가능하다.
원본 객체에 직접 접근하지 않기 때문에 보안성이 향상되고 지연 초기화를 통해 객체가 필요한 순간에 필요한 객체만 초기화하여 사용하므로 불필요한 객체의 생성을 줄일 수 있다는 장점이 있다. 반면 객체 간의 중간 계층이 추가되어 코드의 복잡성이 증가하고 성능이 저하될 수 있다는 단점이 존재한다.<br/>
프록세 패턴은 구조적인 면에서 데코레이터 패턴과 유사하지만 사용 의도에서 명확한 차이가 있다. 프록시 패턴은 실제 객체에 대한 접근을 제어하는데 초점이 맞춰져 있는 반면 데코레이터 패턴은 기존 객체의 기능을 확장하는데 중점을 둔다. 따라서 두 패턴을 적용할 때 목적이 '접근 제어'인지 '기능 확장'인지 잘 구분해야 할 것이다.

<br/>
<br/>

### 4. 전략 패턴에 대해 설명해보고 언제 사용하는 것이 좋은지 설명해보세요.
- 전략 패턴과 해결할 문제의 결이 비슷한 두 가지 디자인 패턴에 대해 설명해보고 전략 패턴과의 차이점에 대해 설명해보세요.
<br/>
전략 패턴은 실행중에 알고리즘을 선택할 수 있게 하는 행위 소프트웨어 디자인 패턴이다. 특정한 알고리즘들을 정의하고 각 알고리즘을 캡슐화하며 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다. 전략 패턴의 이점은 컨텍스트 코드의 변경 없이 새로운 전략을 추가할 수 있다는 점이다. 즉 요구사항이 변경되었을 때 기존의 코드를 변경하지 않아도 되며 새로운 전략에 대해서는 새로운 클래스를 통해 관리하기 때문에 OCP 원칙을 준수할 수 있다.<br/>
전략 패턴과 유사한 구조를 가지는 디자인 패턴으로는 상태 패턴과 책임 연쇄 패턴이 있다. 그러나 전략 패턴은 이 두가지 패턴과 클라이언트의 관점에서 차별점을 갖는다. 상태 패턴과는 클라이언트가 상태를 직접 조작하는지의 유무에 관한 차이를 보이고 책임 연쇄 패턴과는 클라이언트가 객체의 책임을 아는지의 여부로 둘을 구분할 수 있다.

<br/>
<br/>

### 5. JSP Model 2와 Spring MVC을 차이점 위주로 설명해보세요  
jsp란 html 코드에 자바 코드를 넣어 동적 웹페이지를 생성하는 웹어플리케이션 도구이다. 기존 단순한 html을 서비스하던 웹서버의 기능을 보다 발전시켜 웹 기반의 프로그램을 할 수 있도록 만든 것이다. 모델2 방식은 MVC 구조를 응용한 방식이라고 하는데, 가장 핵심적인 내용은 화면과 데이터 처리를 분리해서 재사용이 가능하도록 하는 구조라는 것이다.<br/>
모델2에서 모든 요청은 컨트롤러를 호출한다. 각 컨트롤러는 자신을 호출하는 특정 URL 경로를 가지고 있다. 이처럼 컨트롤러의 URL을 통해 뷰를 제어하기 때문에 뷰의 유지보수에 유용하다.<br/>
그러나 컨트롤러 간의 중복 코드 등의 문제로 모델2 방식은 좀 더 강제적인 형태의 front controller 방식을 적용하게 된다. 가장 주요한 변화는 전체 로직의 일부만을 컨트롤러가 처리하도록 변경되었다는 것이다. 전체 로직의 일부를 컨트롤러에게 위임하고 모든 흐름의 제어는 front controller가 담당한다.<br/>
MVC는 사용자의 모든 요청을 front controller에 전달하고, 전달된 요청은 적절한 컨트롤러를 찾아 호출하게 된다. 이때 사용되는 컨트롤러의 작업은 개발자의 몫인데 이 덕분에 스프링 MVC를 사용하면 개발의 전체 흐름은 개발자가 제어하지 않고 필요한 부품을 끼워넣는 형태의 작업을 하게 된다.











